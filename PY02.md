## 输出函数 print

**print(value,...,sep=‘ ’,end=‘\n’,file=None)**

- sep，分隔符，同一行输出两个变量以上会用一个空格符间隔开

- end，换行符‘\n’，多条print输出控制台换行显示，修改换行符则取消默认换行，`end='--->（其他...）'`

- 连接符 ：+，连接两个字符串

- file，将输入的内容写到文件中

  ```py
  fp=open('note.txt','w')
  print('北京欢迎你',file=fp)
  fp.close()
  ```

  

## 输入函数 input

**input(‘xxxxx’)**

输入的是字符串类型



## 保留字

```py
# 查询保留字
import keyword
print(keyword.kwlist)
```

赋予特定意义的一些单词，不能作为变量、函数、类、模块和其他对象来使用，保留字是严格区分大小写的

|   and    | as     | assert | break  | class   | continue |  def   |
| :------: | ------ | ------ | ------ | ------- | :------: | :----: |
|   del    | elif   | else   | except | finally |   for    |  from  |
|  False   | global | if     | import | in      |    is    | lambda |
| nonlocal | not    | None   | or     | pass    |  raise   | return |
|   try    | True   | while  | with   | yield   |  await   | async  |



## 标识符

- 可以是字符（英文、中文）、下划线 _  和数字，**但第一个字符不能是数字**
- 不能使用保留字
- 严格区分大小写
- 下划线开头的标识符具有特殊意义
- 可以使用中文来做标识符
- **Pascal风格**：类名采用单词首字母大写形式，MyClass
- 模块内部的类采用“_”+Pascal风格，在MyClass中的内部类 _InnerMyClass
- 函数、类的属性和方法的命名，全部使用小写字母，多个字木之间使用下划线分隔
- **单下划线开头的模块变量或函数是受保护的，是不能被导入使用的**
- **双下划线开头的实例变量或方法是类私有的**
- 双下划线开头和结尾的是py的专用标识，_ _ init_ _()标识初始化函数



## 类型

![image-20240820143935476](C:\Users\李晓慧\Desktop\笔记\image-20240820143935476.png)

 

## eval函数

py的内置函数，**用于去掉字符串最外侧的引号**，并按照Python语句方式执行去掉引号后的字符串，**转换为真实的数据类型**

常与input()函数使用，用来获取用户输入的数值

**`变量=eval(字符串)`**

```py
s='3.14+3'
print(s)  # 3.14+3  str

x=eval(s)
print(x) # 6.140000000000001 float

age=eval(input('请输入您的年龄:')) # 将字符串类型转成了int类型，相当于int(age)
print(age,type(age))  # 18 int

height=eval(input('请输入您的身高:'))
print(height,type(height))  # 187.6 float
```



## 运算符

### 赋值运算符

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240820152424334.png" alt="image-20240820152424334" style="zoom: 67%;" />

```py
# 链式赋值
a=b=c=100
print(a,b,c) # 100 100 100

# 解包赋值
a,b=10 ,'sdfkjk'
print(a,b) # 10 sdfkjk

# 交换两个变量
a,b=b,a
print(a,b) # sdfkjk 10
```



### 比较运算符

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240820152755631.png" alt="image-20240820152755631" style="zoom: 67%;" />



### 逻辑运算符

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240820153124779.png" alt="image-20240820153124779" style="zoom:80%;" />

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240820153821025.png" alt="image-20240820153821025" style="zoom: 80%;" />

**not 表示取反，True即False，False即True**



##  if

```py
# 双分支表达
if 表达式：
	语句1
else:
    语句2

```

```py
# 多分支表达
if 表达式1：
	语句1
elif 表达式2:
    语句2
elif 表达式n:
    语句n
else:
    语句n+1
# else可以不写
```

 **elif语句可以写多个**

**判断语句之间是互斥的**

**空格缩进不可省略**



**嵌套使用：**

嵌套的关键在于**空格缩进**，通过空格缩进来决定语句之间的层次关系

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240820194401663.png" alt="image-20240820194401663" style="zoom: 80%;" />



## 模式匹配 match

Python 3.10以上版本适用

```py
score=input('请输入你的成绩:')
match score:
    case 'A':
        print('优秀')
	case 'B':
        print('良好')
	case 'C':
        print('不及格')
```



## 结构模型匹配 match data

```py
match data:
    case {}:
        pass
    case []:
        pass
    case ():
        pass
    case _:
       pass
```

3.10以上使用

```py
data=eval(input('请输入：'))
match data:
    case {'name':'ls','age':20}:
        print('字典')
    case [10,20,30]:
        print('列表')
    case (10,20,30):
        print('元组')
    case _:
        print('相当于多重if中的else')
```



## 同步迭代 match data1,data2

3.10以上版本

```py
match data1,data2:
    case data1,data2:
        pass
```

```py
date1=['apple','orange','pear','grape']
data2=[10,3,4,5]

for f,c in zip(data1,data2):
    match f,c:
        case 'apple'10:
            print('10个苹果')
        case 'orange',3:
            print('3个桔子')
        case 'pear',4:
            print('4个梨')
        case 'grape',5:
            print('5串葡萄')
 '''
 10个苹果
 3个桔子
 4个梨
 5串葡萄
 '''
```



## for

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240820200428475.png" alt="image-20240820200428475" style="zoom: 67%;" />

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240820201515915.png" alt="image-20240820201515915" style="zoom:80%;" />

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240820200707656.png" alt="image-20240820200707656" style="zoom: 67%;" />

```py
for i in range(1,5):
    print(i)
else:
    print('22222')

#1
#2
#3
#4
#22222
```



## range()

内置函数，产生一个[n,m)的数字序列，不包括m

range**生成的是一个不可变的序列**，实际上它返回的是一个迭代器（range对象），这意味着它不会占用大量内存，特别是在生成大范围的序列时。

#### range(num):

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240325193342030.png" alt="image-20240325193342030" style="zoom:80%;" />

 

#### range(num1,num2)

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240325193455208.png" alt="image-20240325193455208" style="zoom:80%;" />

#### range(num1,num2,step)

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240325193536595.png" alt="image-20240325193536595" style="zoom:80%;" />

## while

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240820201719077.png" alt="image-20240820201719077" style="zoom: 67%;" />

![image-20240820202713425](C:\Users\李晓慧\Desktop\笔记\image-20240820202713425.png)

非正常结束不会执行else语句



## continue

中断本次循环，直接进入下一次循环，只作用在离自己最近的作用域上



## break

直接结束该循环



## pass

Python中的保留字，在语法结构中只起到占位符的作用，使语法结构完整，不报错



## 序列

序列指内容连续，有序，**可使用下标索引的一类数据容器（列表、元组、字符串等）**

### 切片

用于从序列（列表、元组、字符串）中**获取一部分元素**，切片**返回的是原始序列中指定范围内的一个新序列（浅拷贝）**【注意 切片 与 range  的区别】

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240820215539843.png" alt="image-20240820215539843"  />

![image-20240820215732927](C:\Users\李晓慧\Desktop\笔记\image-20240820215732927.png)

### 序列操作

![image-20240821145600118](C:\Users\李晓慧\Desktop\笔记\image-20240821145600118.png)



## 迭代对象、迭代器

### 可迭代对象：指实现了`__iter__()`方法的对象

1. **可迭代对象是任何可以被for循环迭代的对象，或者可以被iter()函数调用并返回一个迭代器的对象**
2. 可迭代对象通常有一个`__iter__()`方法，该方法返回一个迭代器
3. 常见的可迭代对象包括列表、元组、字典、集合、字符串等



### 迭代器：指实现了`__iter__()`和`__next__()`两个方法的对象

1. **迭代器是一个具有`__iter__()`和`__next()__`方法的对象**，**`__iter__()`方法返回迭代器自身，`__next()__`方法返回迭代的下一个元素**
2. 迭代器的目的是一个提供有序的方式来访问集合中的元素，直到所有元素都被访问完毕
3. 迭代器通常只用于一次遍历，一旦迭代完成（即抛出StopIteration异常），迭代器就不再有用了



【区别】

- 可迭代对象是数据容器，迭代器是访问这些数据的方式
- 方法：可迭代对象必须实现`__iter__()`方法，而迭代器必须实现`__iter__()`和`__next__()`方法
- 生命周期：可迭代对象可以被多次迭代（例如，列表可以被迭代多次），但标准的迭代器对象在迭代完成后就不能再使用了（除非重新创建）
- 可迭代对象通常用于`for`循环，而迭代器通常用于需要显式控制迭代过程的场景，或者实现自定义的迭代逻辑

```py
# 可迭代对象示例
my_list = [1, 2, 3]
for item in my_list:  # my_list是可迭代对象
    print(item)

print('----------------------')
# 迭代器示例
my_iter = iter(my_list)  # 通过iter()获取迭代器
while True:
    try:
        item = next(my_iter)  # 使用迭代器的__next__()方法
        print(item)
    except StopIteration:
        print('迭代结束')
        break  # 迭代器耗尽时，抛出StopIteration异常

#输出：
1
2
3
----------------------
1
2
3
迭代结束
```

【文章参考】[Python中的迭代器与可迭代对象：深入剖析-百度开发者中心 (baidu.com)](https://developer.baidu.com/article/detail.html?id=3298974)

加强理解，举例说明 `dict.items()`：

```py
my_dict = {'a': 1, 'b': 2, 'c': 3}

#方式1：for循环来迭代字典时，背后的机制会自动调用next()来获取下一个元素，直到迭代器中没有更多元素，此时会抛出StopIteration异常，for循环随之结束
for key, value in my_dict.items():
    print(f'Key: {key}, Value: {value}')

print('--------------')
    
    
# 方式2：手动使用next()迭代

#迭代器的底层工作机制，通过显式调用next()来获取下一个元素，并在迭代结束时捕获StopIteration异常

# 获取字典items()方法的迭代器
items_iter = iter(my_dict.items())

# 使用next()函数来手动迭代
try:
    while True:  # 使用无限循环来模拟迭代过程
        key, value = next(items_iter)  # 显式调用next()获取下一项
        print(f'Key: {key}, Value: {value}')
except StopIteration:
    # 当迭代器耗尽时，捕获StopIteration异常
    print('迭代结束')
    
# 输出：
Key: a, Value: 1
Key: b, Value: 2
Key: c, Value: 3
--------------
Key: a, Value: 1
Key: b, Value: 2
Key: c, Value: 3
迭代结束
```



## 数据容器

| 数据类型 |    序列类型    |     元素是否可以重复     | 是否有序 |    符号     |
| :------: | :------------: | :----------------------: | :------: | :---------: |
|   list   |    可变序列    |          可重复          |   有序   |     []      |
|  tuple   | **不可变序列** |          可重复          |   有序   |     ()      |
|   dict   |    可变序列    | key不可重复，value可重复 |   无序   | {key:value} |
|   set    |    可变序列    |         不可重复         |   无序   |     {}      |



### 列表

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240821095007567.png" alt="image-20240821095007567" style="zoom:80%;" />

`list()`是一个内置函数，用于将可迭代对象转换成列表，接受的参数必须是一个对象 

```py
str = list('sass')  # 'sass'是一个字符串，是可迭代的
print(str)  # 输出: ['s', 'a', 's', 's']

str1 = list(range(1, 5))  # range(1, 5)生成一个从1到4的整数序列
print(str1)  # 输出: [1, 2, 3, 4]
```



#### enumerate() 枚举函数--遍历操作

该函数返回一个迭代器，该迭代器生成包含**元素索引和对应值的元组**

```py
my_list = ['a','b','c']

for index,item in enumerate(my_list):
    print(index,item)         # index是序号，不是索引

print('------------------')
# 手动修改序号的起始值,start可以省略不写,直接写1即可
for index,item in enumerate(my_list,start=1):
    print(index,item)

# 输出：
0 a
1 b
2 c
------------------
1 a
2 b
3 c
```



#### 列表的方法

![image-20240821103246426](C:\Users\李晓慧\Desktop\笔记\image-20240821103246426.png)

##### 查找某元素的下标

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240327171551224.png" alt="image-20240327171551224" style="zoom:80%;" />

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240327171752174.png" alt="image-20240327171752174" style="zoom:80%;" />

##### 修改特定位置（索引）的元素值

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240327171919058.png" alt="image-20240327171919058" style="zoom:80%;" />

##### 插入元素

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240327172110360.png" alt="image-20240327172110360" style="zoom:80%;" />

##### 追加元素

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240327172450866.png" alt="image-20240327172450866" style="zoom:80%;" />

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240327172557252.png" alt="image-20240327172557252" style="zoom:80%;" />

##### 删除元素

###### del 列表[下标] 

![image-20240327172838211](C:\Users\李晓慧\Desktop\笔记\image-20240327172838211.png)

###### 列表.pop[下标]，先取出后删除

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240327173055125.png" alt="image-20240327173055125" style="zoom:80%;" />

###### 删除某元素在列表中的第一个匹配项

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240327173246946.png" alt="image-20240327173246946" style="zoom:80%;" />

##### 清空列表

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240327173422443.png" alt="image-20240327173422443" style="zoom:80%;" />

##### 统计某元素在列表内的数量

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240327173511960.png" alt="image-20240327173511960" style="zoom:80%;" />

##### 统计列表内有多少元素

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240327173617706.png" alt="image-20240327173617706" style="zoom:80%;" />

##### 列表反向输出

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240821135626005.png" alt="image-20240821135626005" style="zoom:80%;" />

##### 列表拷贝

![image-20240821135705343](C:\Users\李晓慧\Desktop\笔记\image-20240821135705343.png)



#### 列表排序-----sort（）方法 /  内置函数sorted（）

##### list.sort(key=None,reverse=False) 

![image-20240821141422666](C:\Users\李晓慧\Desktop\笔记\image-20240821141422666.png)

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240821141816937.png" alt="image-20240821141816937" style="zoom:80%;" />



##### sorted(iterable,key=None,reverse=False)  【会产生新的列表对象】

- `iterable`：要排序的可迭代对象
- `key`：一个函数，它会被用来在进行比较之前从每个列表元素中提取一个比较键（比如通过一个函数指定排序的依据）
- `reverse`：布尔值。如果设置为`True`，则列表元素将被逆序排列，默认为`False`

![image-20240821141939550](C:\Users\李晓慧\Desktop\笔记\image-20240821141939550.png)

```py
my_list = [3, 1, 4, 1, 5, 9, 2, 6]
sorted_list = sorted(my_list)  # 默认升序排序
print(sorted_list)  # 输出: [1, 1, 2, 3, 4, 5, 6, 9]

# 使用 key 参数指定排序依据
sorted_list = sorted(my_list, key=lambda x: -x)  # 降序排序
print(sorted_list)  # 输出: [9, 6, 5, 4, 3, 2, 1, 1]

# 使用 reverse 参数进行降序排序
sorted_list = sorted(my_list, reverse=True)
print(sorted_list)  # 输出: [9, 6, 5, 4, 3, 2, 1, 1]
```



#### 列表生成

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240821143118427.png" alt="image-20240821143118427" style="zoom:80%;" />

```py
import random

list=[item for item in range(10)]
print('list:',list) # list: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

list2=[item*item for item in range(1,11)]
print('list2:',list2) # list2: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

list3=[random.randint(1,100) for _ in range(10)]
print('list3',list3)  # list3 [31, 65, 75, 87, 73, 7, 14, 7, 44, 67]

list4=[i for i in range(10) if i%2==0]
print('list4:',list4)  # list4: [0, 2, 4, 6, 8]
```



#### 二维列表

```py

s=[
    ['类型','分值','等级'],
    ['A',90,'优秀'],
    ['C',60,'及格'],
    ['B',80,'良好'],
]
print(s)  # [['类型', '分值', '等级'], ['A', 90, '优秀'], ['C', 60, '及格'], ['B', 80, '良好']]

# 遍历二维列表，双层for循环
for row in s:
    for item in row:
        print(item,end='\t')
    print()   

'''
类型	分值	等级	
A	90	优秀	
C	60	及格	
B	80	良好
'''

# 生成二维列表
lst=[[j for j in range(5)] for i in range(4)]
print(lst)  # [[0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4]]
```



### 元组

**不可变序列**，无法实现添加，删除和修改元素等操作

![image-20240821145153555](C:\Users\李晓慧\Desktop\笔记\image-20240821145153555.png)

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240821145208614.png" alt="image-20240821145208614"  />

【注意】

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240822150937781.png" alt="image-20240822150937781" style="zoom:80%;" />

#### 元组方法

![image-20240821145312995](C:\Users\李晓慧\Desktop\笔记\image-20240821145312995.png)

**删除元组： del 元组名**



#### 元组访问、遍历

```py
# 定义一个元组
t=('python','java','golang')
print(t[0]) # 索引访问  python

# 切片
t2=t[0:3:2]
print(t2)   # ('python', 'golang')

# 遍历1
for item in t:
    print(item)

'''
python
java
golang
'''

# for+range+len() 遍历2
for item in range(len(t)):
    print(item,t[item])
'''
0 python
1 java
2 golang
'''

# enumerate() 遍历3
for index,item in enumerate(t,1):
    print(index,'--->',item)
'''
1 ---> python
2 ---> java
3 ---> golang
'''
```



### 字典

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240331095459387.png" alt="image-20240331095459387" /> 



#### zip() 

它用于将多个可迭代对象中对应的元素打包成一个个元组（tuple）

**通过 映射函数zip(）和 内置函数dict() 创建字典：zip(lst1,lst2)** 

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240822151803088.png" alt="image-20240822151803088" style="zoom:120%;" />

#### 字典的遍历

![image-20240822152053420](C:\Users\李晓慧\Desktop\笔记\image-20240822152053420.png)

```py
d={'mike':10,'jack':18,'rose':21}
print(d.get('jack'))  # 18

# 遍历
for item in d.items():
    print(item)
'''
('mike', 10)
('jack', 18)
('rose', 21)
'''

for key,value in d.items():
    print(key,'----->',value)
'''
mike -----> 10
jack -----> 18
rose -----> 21
'''
```



#### 字典的方法

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240822151850138.png" alt="image-20240822151850138" style="zoom:80%;" />



#### 字典生成式

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240822152926677.png" alt="image-20240822152926677" style="zoom: 67%;" />

```py
import random
d={item:random.randint(1,10) for item in range(4)}
print(d)  # {0: 2, 1: 1, 2: 3, 3: 10}

lst1=[10,20,30]
lst2=['car','gff','fdwe']
a={key:value for key,value in zip(lst1,lst2)}
print(a)  # {10: 'car', 20: 'gff', 30: 'fdwe'}
```



#### 字典合并运算符 |

3.11以上版本用

```py
d1={'a':'ls','b':20}
d2={'c':'ls','d':20}
m=d1|d2
print(m)  # {'a':'ls','b':20,'c':'ls','d':20}
```



### 集合

无序的、不重复的序列，**存储不可变数据类型**

![image-20240822153845157](C:\Users\李晓慧\Desktop\笔记\image-20240822153845157.png)

**使用内置函数set()创建集合：  s= set(可迭代对象)**



#### 集合的操作

![image-20240822155945766](C:\Users\李晓慧\Desktop\笔记\image-20240822155945766.png)



#### 集合的方法

![image-20240822160700545](C:\Users\李晓慧\Desktop\笔记\image-20240822160700545.png)



#### 集合的遍历、生成

```py
s={10,20,30}

for item in s:
    print(item)
'''
10
20
30
'''

# enumerate()函数
for index,item in enumerate(s):
    print(index,'---->',item)
'''
0 ----> 10
1 ----> 20
2 ----> 30
'''

# 生成
s={i for i in range(10)}
print(s)   # {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

s={i for i in range(1,10) if i%2==1}
print(s)  # {1, 3, 5, 7, 9}
```

 

### 字符串

**字符串是一个无法修改的数据容器**

#### 字符串的方法

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240822191251654.png" alt="image-20240822191251654" style="zoom:80%;" />

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240822191325563.png" alt="image-20240822191325563" style="zoom: 67%;" />

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240822191711271.png" alt="image-20240822191711271" style="zoom:80%;" />

#### 字符串格式化

占位符：

![image-20240822192128666](C:\Users\李晓慧\Desktop\笔记\image-20240822192128666.png)

字符串快速格式化------->   f "内容{变量}"      【不做精度控制，不限数据类型，原样输出】

format方法：`print(‘姓名{0}，年龄:{1}，成绩:{2}’.format(name.age,score))`     【{ }对应的是索引位置】



#### 编码、解码

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240822193634257.png" alt="image-20240822193634257" style="zoom: 60%;" />

```py
str='伟大的中国梦'

# 编码
str_code=str.encode()
print(str_code)

# 解码 
str_decode=bytes.decode(str_code)
print(str_decode
```



#### 数据验证

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240822193751495.png" alt="image-20240822193751495" style="zoom:67%;" />

## 正则

### 元字符匹配

![　](C:\Users\李晓慧\Desktop\笔记\image-20240822201534074.png)

### 限定符

限定匹配的次数

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240822201622977.png" alt="image-20240822201622977" style="zoom:80%;" />

### 其他字符

![image-20240822202051652](C:\Users\李晓慧\Desktop\笔记\image-20240822202051652.png)

### re模块

![image-20240822202531764](C:\Users\李晓慧\Desktop\笔记\image-20240822202531764.png)

```py
import re
pattern='\d\.\d+' #0-9数字出现1次或多次
s='i am study py 3.11 day by day'
match=re.match(pattern,s,re.I)
print(match) # None

s2='3.11 py day'
match2=re.match(pattern,s2)
print(match2)  # <re.Match object; span=(0, 4), match='3.11'>

match3=re.search(pattern,s)
print(match3)  # <re.Match object; span=(14, 18), match='3.11'>

match4=re.findall(pattern,s)
print(match4)  # ['3.11']
```

```py
pattern2='黑客|破解'
s3='爬虫腾讯，破解VIP视频，用黑客身份实现'
match5=re.sub(pattern2,'***',s3)
print(match5)  # 爬虫腾讯，***VIP视频，用***身份实现

pattern3='[?|%]'
s4='https://baike.sogou.com/v4297323.htm?fromTitle=%E8%B5%B5%E4%B8%BD%E9%A2%96'
match6=re.split(pattern3,s4)
print(match6)  # ['https://baike.sogou.com/v4297323.htm', 'fromTitle=', 'E8', 'B5', 'B5', 'E4', 'B8', 'BD', 'E9', 'A2', '96']
```



## 异常

| 类型              | 说明                               |
| ----------------- | ---------------------------------- |
| ZeroDivisionError | 当除数为0时，引发的异常            |
| IndexError        | 索引超出范围引发的异常             |
| KeyError          | 字典取值时key不存在的异常          |
| NameError         | 使用一个没有声明的变量时引发的异常 |
| SyntaxError       | Python中的语法错误                 |
| ValueError        | 传入的值错误                       |
| AttributeError    | 属性或方法不存在的异常             |
| TypeError         | 类型引发的异常                     |
| IndentationError  | 不正确的缩进引发的异常             |



<img src="C:\Users\李晓慧\Desktop\笔记\image-20240822214649393.png" alt="image-20240822214649393" style="zoom:67%;" />

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240822215054571.png" alt="image-20240822215054571" style="zoom: 67%;" />

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240822215149229.png" alt="image-20240822215149229" style="zoom:85%;" />

### raise关键字：   raise[Exception类型（异常描述信息）]

抛出一个异常，提醒程序出现了异常情况

```py
try:
    gender=input('输入性别：')
    if gender!='男' and gender!='女':
        raise  Exception('性别只能是男或女')
    else:
        print(f'您的性别是{gender}')
except Exception as e:
    print(e)
```



## 变量

### 局部变量

在函数定义处的参数和函数内部定义的变量，仅在函数内部作用，函数执行结束，局部变量的生命周期也结束了



### 全局变量 ：global关键字

作用于整个程序。程序运行结束，全局变量的生命周期才结束

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240823103706232.png" alt="image-20240823103706232" style="zoom:80%;" />



## 函数

函数定义：

使用关键字**def**

### 位置参数

指调用时的参数个数和顺序必须与定义的参数个数和顺序

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240823100438280.png" alt="image-20240823100438280" style="zoom:80%;" />

### 关键字参数

顺序可以不同

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240823100915609.png" alt="image-20240823100915609" style="zoom:80%;" />

### 默认参数（缺省参数）

![image-20240823101153767](C:\Users\李晓慧\Desktop\笔记\image-20240823101153767.png)

### 可变参数（不定长参数）

在不确定参数个数时使用

#### 位置传递

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240823102109526.png" alt="image-20240823102109526" style="zoom:130%;" />

#### 关键字传递

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240823102144150.png" alt="image-20240823102144150" style="zoom:80%;" />



## lambda 匿名函数

指没有名字的函数，**只能使用一次**，一般是在函数的函数体只有一句代码且只有一个返回值时，可以使用匿名函数

```py
result  =  lambda 参数列表：表达式
```

```py
# 普通函数
def calc(a,b):
    return a+b

print(calc(10,20))  # 30

# 匿名函数
s=lambda a,b:a+b
print(type(s)) # <class 'function'>
print(s(10,20)) # 30
```



```py
my_list=[
    ['a',30],
    ['b',20],
    ['c',50]
]

my_list.sort(key=lambda x:x[1],reverse=True)
print(my_list)  # [['c', 50], ['a', 30], ['b', 20]]
```



## 递归函数

```py
def fac(n):
    if n==1:
        return 1
    else:
        return n*fac(n-1)

print(fac(5))
```

## 斐波那契

1、1、2、3、5、8、13、21、34、....从第三项开始每项等于前两项之和

```py
def fac(n):
    if n==1 or n==2:
        return 1
    else:
        return fac(n-1)+fac(n-2)

print(fac(9)) #34

for i in range(1,10):
    print(fac(i),end='\t')
print()  #  1	1	2	3	5	8	13	21	34
```



## 内置函数

### 类型转换函数

```py
print('非空字符串:',bool('hello')) # 非空字符串: True
print('空字符串:',bool(''))       #  空字符串: False

lst=[10,20,30]                  
print(type(lst))                # <class 'list'>
print(type(str(lst)))           # <class 'str'>

print(int(98.7)+int('10'))      # 108

print(float(90)+float(3.14))    # 93.14

str='word'
print(list(str))                # ['w', 'o', 'r', 'd']
print(tuple(str))               # ('w', 'o', 'r', 'd')
print(set(str))                 # {'d', 'r', 'o', 'w'}
```



### 数学函数

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240823113657213.png" alt="image-20240823113657213" style="zoom:70%;" />

### 迭代器函数

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240823142901590.png" alt="image-20240823142901590" style="zoom:60%;" />

filter()函数用于过滤可迭代对象中的元素，只返回使给定函数返回值为True的元素，根据条件筛选元素，只保留满足条件的元素。需要一个函数和一个可迭代对象作为参数。传入的函数应该返回一个布尔值，返回的是一个迭代器。

map()函数用于对可迭代对象中的每一个元素应用一个给定的函数，并返回一个迭代器（新的序列）。



```py
def fun(num):
    return num%2==1

obj=filter(fun,range(10))  # 将range(10),0-9的整数都执行一次fun操作,只有True才会给obj
print(obj)  # <filter object at 0x00000225134EF700>
print(list(obj))  # [1, 3, 5, 7, 9]

def upper(x):
    return x.upper()

lst=['hello','world','python']
obj2=map(upper,lst)
print(obj2)  # <map object at 0x000001677BB047C0>
print(list(lst))  # ['hello', 'world', 'python']
```



## 面向对象、面向过程

对象是类的实例

**面向对象**：是一种**以数据为中心**的编程范式，它使用“对象”来设计软件。

特点：1.对象为中心，程序由一系列对象组成，每个对象都是数据和处理数据的代码的集合

​			2.封装，隐藏对象的内部状态和细节，只暴露一个可以被外界访问的接口

​			3.继承，允许新创建的类（子类）继承现有类（父类）的属性和方法

​			4.多态，允许不同类的对象对同一消息做出响应，具体行为会根据对象的实际类型而有所不同



**面向过程**：是一种**以过程为中心**的编程范式，将计算分解为一系列的过程或函数。每个函数完成特定的任务，并且可以被其他函数调用。

特点：1.函数为中心，程序由一系列函数或子程序组成，每个函数执行特定的任务

​			2.数据和函数分离，数据结构和处理数据的函数是分开的，函数操作数据但不包含数据

​			3.模块化，程序被分解为模块，每个模块包含一组相关的函数

​			4.过程抽象，关注点在于执行任务的步骤



## 类

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240825145035408.png" alt="image-20240825145035408" style="zoom:85%;" />

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240825145224747.png" alt="image-20240825145224747" style="zoom:80%;" />

**传参的时候可以忽略self**

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240825145306586.png" alt="image-20240825145306586" style="zoom:80%;" />

### object类  

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240826135538736.png" alt="image-20240826135538736" style="zoom:120%;" />



## 构造方法  _ _ init _ _()

- 构造方法用于设置对象的状态，包括为对象的属性赋值
- 当创建一个类实例时，python解释器会自动调用`__init__()`方法
- 构造方法不返回任何值，特别是不返回None，如果他返回任何值，Python解释器会忽略它

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240825145537184.png" alt="image-20240825145537184" style="zoom:80%;" />

## super()

内置函数，**提供对父类（超类）方法的访问**。在子类中重写父类的方法或构造函数时，super()允许你调用父类中相应的方法

- 在子类中重写父类的方法时，使用super()来扩展而不是完全替换父类的行为
- 在子类的`__init__()`方法中使用`super()`来确保父类的构造方法被正确调用，从而完成父类属性的初始化

```py
class Parent:
    def __init__(self, name):
        self.name = name

class Child(Parent):
    def __init__(self, name, age):
        super().__init__(name)  # 调用父类的初始化方法
        self.age = age

child = Child("Alice", 30)
print(child.name)  # 输出: Alice
```



## 继承

**单继承**

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240826101054245.png" alt="image-20240826101054245" style="zoom:70%;" />

**多继承**

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240826101658477.png" alt="image-20240826101658477" style="zoom:80%;" />

```py
class FatherA:
    def __init__(self,name):
        self.name=name

    def showA(self):
        print('父类A的方法')


class FatherB:
    def __init__(self, name):
        self.name = name

    def showB(self):
        print('父类B的方法')

class Son(FatherA,FatherB):
    def __init__(self,name,age,gender):
        FatherA.__init__(self,name)
        FatherB.__init__(self,age)
        self.gender=gender

son=Son('jack',18,'男')
son.showA()
son.showB()
'''
父类A的方法
父类B的方法
'''
```



## 方法重写

在子类中重写父类的属性或方法

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240826104808558.png" alt="image-20240826104808558" style="zoom: 80%;" />

```py
class Person:
    def __init__(self,name,age):
        self.name=name
        self.age=age

    def show(self):
        print(f'大家好，我是{self.name},今年{self.age}岁')

class Student(Person):
    def __init__(self, name, age,stuno):
        super().__init__(name,age)
        self.stuno=stuno

    def show(self):
        # 调用父类中的方法（也可以不调用）
        super().show()
        print(f'我来自xxx大学，学号是{self.stuno}')

class Doctor(Person):
    def __init__(self, name, age,deparment):
        super().__init__(name,age)
        self.deparment=deparment

    def show(self):
        print(f'大较好，我叫{self.name},工作科室{self.deparment}')

stu=Student('陈美美',18,'1234')
stu.show()  # 调用子类自己的show()方法

doctor=Doctor('jack',24,'心外科')
doctor.show()  # 调用子类自己的show()方法
```



## 多态

在程序运行过程中根据变量所引用对象的数据类型，动态决定调用哪个对象中的方法

![image-20240826135159865](C:\Users\李晓慧\Desktop\笔记\image-20240826135159865.png)



## 封装

### 私有成员

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240409212212661.png" alt="image-20240409212212661" style="zoom:80%;" />

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240409212238529.png" alt="image-20240409212238529" style="zoom:80%;" />

 

![image-20240409212937894](C:\Users\李晓慧\Desktop\笔记\image-20240409212937894.png)

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240409213707532.png" alt="image-20240409213707532" style="zoom:80%;" />



## 类型注解

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240827173700443.png" alt="image-20240827173700443" style="zoom:80%;" />

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240827173709630.png" alt="image-20240827173709630" style="zoom:80%;" />

## Union类型

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240827173745992.png" alt="image-20240827173745992" style="zoom:80%;" />

定义联合类型注解



## 魔术方法（特殊方法）

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240826135937353.png" alt="image-20240826135937353" style="zoom:80%;" />

```py
a=10
b=20
print(dir(a))  # python中一切皆对象
print(a.__add__(b))   # 30
print(a.__sub__(b))   # -10
print(a.__lt__(b))    # True
print(a.__le__(b))    # True
print(a.__eq__(b))    # False
```



```py
class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __le__(self, other):
        return self.age <= other.age

stu1=Student('jack',13)
stu2=Student('cc',24)
print(stu1<=stu2)  # True
print(stu1>=stu2)  # False
```



## 特殊属性

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240826141208500.png" alt="image-20240826141208500" style="zoom:80%;" />

```py
class A:
    pass
class B:
    pass
class C(A,B):
    def __init__(self,name,age):
        self.name=name
        self.age=age

a=A()
b=B()
c=C('jakc',25)

print(a.__dict__)  # {}
print(b.__dict__)  # {}
print(c.__dict__)  # {'name': 'jakc', 'age': 25}

print(a.__class__) # <class '__main__.A'>
print(b.__class__) # <class '__main__.B'>
print(c.__class__) # <class '__main__.C'>

print(A.__base__) # <class 'object'>
print(B.__base__) # <class 'object'>
print(C.__base__) # <class '__main__.A'>  如果继承了多个父类，结果只显示第一个父类

print(A.__bases__) # (<class 'object'>,)
print(B.__bases__) # (<class 'object'>,)
print(C.__bases__) # (<class '__main__.A'>, <class '__main__.B'>)

print(A.__mro__) # (<class '__main__.A'>, <class 'object'>)
print(B.__mro__) # (<class '__main__.B'>, <class 'object'>)
print(C.__mro__) # (<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>) C类首先继承了A,B类，间接继承了object类
```



## 浅拷贝、深拷贝

浅拷贝：对象包含的子对象内容不拷贝，源对象与拷贝对象会引用同一个子对象

深拷贝：`deepcopy`，创建一个新对象，并且**递归地复制原对象中包含的所有对象**。源对象与拷贝对象所有的子对象不相同

```py
import copy
class CPU:
    pass
class Disk:
    pass
class Computer:
    def __init__(self,cpu,disk):
        self.cpu=cpu
        self.disk=disk

cpu=CPU()
disk=Disk()
com=Computer(cpu,disk)
print(com)

com1=com
print(com1,com1.cpu,com1.disk)

print('-'*40)
# 浅拷贝
com2=copy.copy(com1)
print(com2,'浅拷贝的子对象内存地址：',com2.cpu,com2.disk)

print('-'*40)
# 深拷贝
com3=copy.deepcopy(com1)
print(com3,'深拷贝的子对象内存地址',com3.cpu,com3.disk)

'''
<__main__.Computer object at 0x0000013F77AE44F0>
<__main__.Computer object at 0x0000013F77AE44F0> <__main__.CPU object at 0x0000013F77B1F700> <__main__.Disk object at 0x0000013F77AE47C0>
----------------------------------------
<__main__.Computer object at 0x0000013F7802F2B0> 浅拷贝的子对象内存地址： <__main__.CPU object at 0x0000013F77B1F700> <__main__.Disk object at 0x0000013F77AE47C0>
----------------------------------------
<__main__.Computer object at 0x0000013F7802F370> 深拷贝的子对象内存地址 <__main__.CPU object at 0x0000013F780463D0> <__main__.Disk object at 0x0000013F78046400>

'''
```



## 模块

![image-20240826175556985](C:\Users\李晓慧\Desktop\笔记\image-20240826175556985.png)

## 包

含有`__init__.py`文件的文件夹（目录）

导包

`import 包名.模块名`

`包名.模块名.目标`



### ＿_ main _ _　变量

`__main__` 是顶层代码运行环境的名称。“顶层代码”是指由用户指定的最先开始运行的那一个 Python 模块.

主程序运行：

```py
if __name__ = '__main__':
	pass
```

如果当前模块被直接执行（作为主程序），而不是被导入到其他模块中，则执行紧跟在该语句后面的代码块（当程序是直接执行的，那么if才会进入下面的代码块，如果是被导入的则if无法进入），这样做阻止了全局变量的数据被输出执行



### ＿_ all _ _　变量

能够准确导入功能

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240405154852755.png" alt="image-20240405154852755" style="zoom:80%;" />



## request模块

爬虫

```py
import requests
import re
url='https://www.weather.com.cn/weather1d/101010100.shtml#search'
resp=requests.get(url)
resp.encoding='utf-8'
# print(resp.text)

city=re.findall('<span class="name">([\u4e00-\u9fa5]*)</span>',resp.text)
print(city)

weather=re.findall('<span class="weather">([\u4e00-\u9fa5]*)</span>',resp.text)
print(weather)

wd=re.findall('<span class="wd">(.*)</span>',resp.text)
print(wd)

zs=re.findall('<span class="zs">([\u4e00-\u9fa5]*)</span>',resp.text)
print(zs)

lst=[]
for a,b,c,d in zip(city,weather,wd,zs):
    lst.append([a,b,c,d])

print(lst)

for i in lst:
    print(i)
```



## openpyxl 模块

`pip install openpyxl`

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240826195349161.png" alt="image-20240826195349161" style="zoom: 67%;" />

创建

```py
import requests
import re
import openpyxl

def get_html():
    url = 'https://www.weather.com.cn/weather1d/101010100.shtml#search'
    resp = requests.get(url)
    resp.encoding = 'utf-8'
    return resp.text

def parse_html(html_str):
    city = re.findall('<span class="name">([\u4e00-\u9fa5]*)</span>', html_str)
    weather = re.findall('<span class="weather">([\u4e00-\u9fa5]*)</span>', html_str)
    wd = re.findall('<span class="wd">(.*)</span>', html_str)
    zs = re.findall('<span class="zs">([\u4e00-\u9fa5]*)</span>', html_str)

    lst = []
    for a, b, c, d in zip(city, weather, wd, zs):
        lst.append([a, b, c, d])
    # print(lst)
    return lst

data=parse_html(get_html())
print(data)
# 创建Excel
workbook=openpyxl.Workbook()
# 在Excel中创建表
sheet=workbook.create_sheet('景点天气')
# 添加数据
for i in data:
    sheet.append(i)

workbook.save('景区天气.xlsx')
```

读取

```py
import openpyxl
# 打开工作簿
workbook=openpyxl.load_workbook('景区天气.xlsx')
# 选择要操作的工作表
sheet=workbook['景点天气']
lst=[]
# 表格数据是二维数列，先遍历行，再遍历列
for row in sheet.rows:
    sub_lst=[]  # 存储单元格数据
    for cell in row:  # 单元格
        sub_lst.append(cell.value)
    lst.append(sub_lst)

for i in lst:
    print(i)
```

## 其他模块

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240826203530596.png" alt="image-20240826203530596" style="zoom:80%;" />

```py
import pdfplumber
#打开PDF文件
with pdfplumber.open('小学数学-公式.pdf') as pdf:
    for i in pdf.pages:#遍历页
		print(i.extract_text())#extract_text()方法提取内容
        print(f'----------第{i.page_number}页结束')
```

```py
import numpy
import matplotlib.pyplot as plt

# 读取图像
n1 = plt.imread('img.png')

# 确保图像是RGB格式的
if n1.ndim == 3 and n1.shape[2] == 4:  # 如果图像是RGBA
    n1 = n1[..., :3]  # 只保留RGB通道

# 转换为灰度图像
n2 = numpy.array([0.299, 0.587, 0.114])
gray_image = n1.dot(n2)  # 沿着最后一个维度进行点积

# 显示灰度图像
plt.imshow(gray_image, cmap='gray')
plt.show()
```



## pyecharts

### 基础折线图

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240407090737566.png" alt="image-20240407090737566" style="zoom: 200%;" />

#### 全局配置

配置图表标题、图例、鼠标移动效果、工具栏等

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240407090946156.png" alt="image-20240407090946156" style="zoom:80%;" />

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240407091144695.png" alt="image-20240407091144695" style="zoom: 80%;" />

```py
# 折线图
# 导包
# from pyecharts.charts import Line
# from pyecharts.options import TitleOpts,LegendOpts,ToolboxOpts,VisualMapOpts
# # 创建一个折线图对象
# line = Line()
# # 添加x轴数据
# line.add_xaxis(["中国","美国","英国","日本"])
# # 添加y轴数据
# line.add_yaxis("GDP",[30,20,10,25])
#
# # 配置全局设置
# line.set_global_opts(
#     title_opts=TitleOpts(title="GDP展示",pos_left="center",pos_bottom="1%"),
#     legend_opts=LegendOpts(is_show=True),
#     toolbox_opts=ToolboxOpts(is_show=True),
#     visualmap_opts=VisualMapOpts(is_show=True)
# )
# # 通过render方法，讲代码生成图像
# line.render()

# 处理数据
import json
from pyecharts.charts import Line
from pyecharts.options import TitleOpts,LegendOpts,ToolboxOpts,VisualMapOpts,LabelOpts
f_us=open("D:/pyecharts数据资料/资料/可视化案例数据/折线图数据/美国.txt","r",encoding="UTF-8")
us_data=f_us.read()

f_jp=open("D:/pyecharts数据资料/资料/可视化案例数据/折线图数据/日本.txt","r",encoding="UTF-8")
jp_data=f_jp.read()

f_in=open("D:/pyecharts数据资料/资料/可视化案例数据/折线图数据/印度.txt","r",encoding="UTF-8")
in_data=f_in.read()
# 去掉不规范开头
us_data=us_data.replace("jsonp_1629344292311_69436(","")
jp_data=jp_data.replace("jsonp_1629350871167_29498(","")
in_data=in_data.replace("jsonp_1629350745930_63180(","")
# 去掉不规范结尾
us_data=us_data[:-2]
jp_data=jp_data[:-2]
in_data=in_data[:-2]
# 转换为字典
us_dict=json.loads(us_data)
jp_dict=json.loads(jp_data)
in_dict=json.loads(in_data)
# 获取trend key
us_trend_data=us_dict['data'][0]['trend']
jp_trend_data=jp_dict['data'][0]['trend']
in_trend_data=in_dict['data'][0]['trend']
#x轴  获取日期到2020年（下标为314）
us_x_data=us_trend_data['updateDate'][:314]
jp_x_data=jp_trend_data['updateDate'][:314]
in_x_data=in_trend_data['updateDate'][:314]
# y轴  获取日期到2020年（下标为314）
us_y_data=us_trend_data['list'][0]['data'][:314]
jp_y_data=jp_trend_data['list'][0]['data'][:314]
in_y_data=in_trend_data['list'][0]['data'][:314]

# 生成图表
line=Line()
line.add_xaxis(us_x_data)
line.add_yaxis("美国确诊人数",us_y_data,label_opts=LabelOpts(is_show=False))
line.add_yaxis("日本确诊人数",jp_y_data,label_opts=LabelOpts(is_show=False))
line.add_yaxis("印度的确诊人数",in_y_data,label_opts=LabelOpts(is_show=False))
# 全局设置
line.set_global_opts(
    title_opts=TitleOpts(title="2020年美日印确诊人数对比折线图",pos_left="center",pos_bottom="1%"),
    legend_opts=LegendOpts(is_show=True),
    toolbox_opts=ToolboxOpts(is_show=True),
    visualmap_opts=VisualMapOpts(is_show=True)
)
line.render()

# 关闭文件
f_us.close()
f_jp.close()
f_in.close()
```



### 基础地图

![image-20240408154245197](C:\Users\李晓慧\Desktop\笔记\image-20240408154245197.png)

![image-20240408155223852](C:\Users\李晓慧\Desktop\笔记\image-20240408155223852.png)

![image-20240408155835077](C:\Users\李晓慧\Desktop\笔记\image-20240408155835077.png)

```py
# from pyecharts.charts import Map
# from pyecharts.options import VisualMapOpts
# map=Map()
# data=[
#     ("北京市",99),
#     ("上海市",199),
#     ("湖南省",299),
#     ("台湾省",399),
#     ("广东省",499),
# ]
# map.add("测试地图",data,"china")
# # 全局设置
# map.set_global_opts(
#     visualmap_opts=VisualMapOpts(
#         is_show=True,
#         is_piecewise=True,
#         pieces=[
#             {"min":1,"max":9,"label":"1-9","color":"#CCFFFF"},
#             {"min": 10, "max": 99, "label": "10-99", "color": "#FF6666"},
#             {"min": 100, "max": 299, "label": "100-299", "color": "#990033"},
#             {"min": 300, "max": 500, "label": "300-500", "color": "#FF3333"},
#         ]
#     )
# )
#
# map.render()

# 全国地图绘制
# import json
# from pyecharts.charts import Map
# from pyecharts.options import *
# f=open("D:/pyecharts数据资料/资料/可视化案例数据/地图数据/疫情.txt","r",encoding="UTF-8")
# data=f.read()
# f.close()
# # 转换为字典
# data_dict=json.loads(data)
# # 取出省份
# data_province=data_dict["areaTree"][0]["children"]
# # print(data_province)
# # 组装各省份确诊人数到列表内
# data_list=[]
# for province_data in data_province:
#     province_name=province_data["name"]             #省份名称
#     if province_name in ["北京", "天津", "上海", "重庆"]:
#         province_name += "市"  # 特殊行政区添加"市"字
#     elif province_name in ["新疆维吾尔", "西藏", "内蒙古", "广西壮族", "宁夏回族"]:
#         province_name += "自治区"  # 需要添加"自治区"的自治区
#     else:
#         province_name += "省"  # 其他省份添加"省"字
#     province_confirm=province_data["total"]["confirm"]   # 确诊人数
#     data_list.append((province_name,province_confirm))
# # print(data_list)
# map=Map()
# map.add("各省份确诊人数",data_list,"china")
# map.set_global_opts(
#     title_opts=TitleOpts(title="全球疫情地图"),
#     visualmap_opts=VisualMapOpts(
#         is_show=True,
#         is_piecewise=True,
#         pieces=[
#             {"min": 1, "max": 99, "label": "1-9人", "color": "#CCFFFF"},
#             {"min": 100, "max": 999, "label": "100-99人", "color": "#FFFF99"},
#             {"min": 1000, "max": 4999, "label": "1000-4999人", "color": "#FF9966"},
#             {"min": 5000, "max": 9999, "label": "5000-9999人", "color": "#FF6666"},
#             {"min": 10000, "max": 999999, "label": "10000-99999人", "color": "#CC3333"},
#             {"min": 100000, "label": "100000人", "color": "#990033"},
#         ]
#     )
# )
# map.render("全国疫情地图.html")

# 省级地图绘制

import json
from pyecharts.charts import Map
from pyecharts.options import *
f=open("D:/pyecharts数据资料/资料/可视化案例数据/地图数据/疫情.txt","r",encoding="UTF-8")
data=f.read()
f.close()
# 转换为字典
data_dict=json.loads(data)
# 取出省份
data_province=data_dict["areaTree"][0]["children"][3]["children"]
# print(data_province)
data_list=[]
for city_data in data_province:
    city_name=city_data["name"]+"市"
    city_confirm=city_data["total"]["confirm"]
    data_list.append((city_name,city_confirm))
# print(data_list)
data_list.append(("济源市",5))
map=Map()
map.add("河南省疫情分布",data_list,"河南")
map.set_global_opts(
    title_opts=TitleOpts(title="河南省疫情地图"),
    visualmap_opts=VisualMapOpts(
        is_show=True,
        is_piecewise=True,
        pieces=[
            {"min": 1, "max": 99, "label": "1-9人", "color": "#CCFFFF"},
            {"min": 100, "max": 999, "label": "100-99人", "color": "#FFFF99"},
            {"min": 1000, "max": 4999, "label": "1000-4999人", "color": "#FF9966"},
            {"min": 5000, "max": 9999, "label": "5000-9999人", "color": "#FF6666"},
            {"min": 10000, "max": 999999, "label": "10000-99999人", "color": "#CC3333"},
            {"min": 100000, "label": "100000人", "color": "#990033"},
        ]
    )
)
map.render("河南省疫情地图.html")
```

### 基础柱状图

![image-20240408165217563](C:\Users\李晓慧\Desktop\笔记\image-20240408165217563.png)

![image-20240408165635699](C:\Users\李晓慧\Desktop\笔记\image-20240408165635699.png)

#### 创建时间线

![image-20240408165954226](C:\Users\李晓慧\Desktop\笔记\image-20240408165954226.png)

![image-20240408170100383](C:\Users\李晓慧\Desktop\笔记\image-20240408170100383.png)

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240408191924127.png" alt="image-20240408191924127" style="zoom:200%;" />

![image-20240408192131360](C:\Users\李晓慧\Desktop\笔记\image-20240408192131360.png)

```py
# 基础柱状图
# from pyecharts.charts import Bar
# from pyecharts.options import *
# bar=Bar()
# bar.add_xaxis(["中国","美国","日本"])
# bar.add_yaxis("GDP",[30,20,10],label_opts=LabelOpts(position="right"))
# # 反转x轴和y轴
# bar.reversal_axis()
# bar.render()

# 时间柱状图
# from pyecharts.charts import Bar,Timeline
# from pyecharts.options import *
# from pyecharts.globals import ThemeType
#
# bar1=Bar()
# bar1.add_xaxis(["中国","美国","日本"])
# bar1.add_yaxis("GDP",[30,20,10],label_opts=LabelOpts(position="right"))
# bar1.reversal_axis()
#
# bar2=Bar()
# bar2.add_xaxis(["中国","美国","日本"])
# bar2.add_yaxis("GDP",[20,50,45],label_opts=LabelOpts(position="right"))
# bar2.reversal_axis()
#
# bar3=Bar()
# bar3.add_xaxis(["中国","美国","日本"])
# bar3.add_yaxis("GDP",[70,60,50],label_opts=LabelOpts(position="right"))
# bar3.reversal_axis()
#
# timeline = Timeline(
#     {"theme":ThemeType.LIGHT}
# )
# # 构建时间线对象
# timeline=Timeline()
# timeline.add(bar1,"点1")
# timeline.add(bar2,"点2")
# timeline.add(bar3,"点3")
#
# timeline.add_schema(
#     play_interval=1000,
#     is_timeline_show=True,
#     is_auto_play=True,
#     is_loop_play=True
# )
# timeline.render("时间线柱状图.html")

# GDP柱状图
from pyecharts.charts import Bar,Timeline
from pyecharts.options import *
from pyecharts.globals import ThemeType

f=open("D:/pyecharts数据资料/资料/可视化案例数据/动态柱状图数据/1960-2019全球GDP数据.csv","r",encoding="GB2312")
data=f.readlines()
f.close()
# 删除第一条数据
data.pop(0)
# 转换为字典
data_dict={}
for line in data:
    year=int(line.split(",")[0])  #年份
    country=line.split(",")[1]   #国家
    gdp=float(line.split(",")[2])  #GDP
    try:
        data_dict[year].append([country,gdp])
    except KeyError:
        data_dict[year]=[]
        data_dict[year].append([country,gdp])
# print(data_dict)
# 年份排序
sorted_year=sorted(data_dict.keys())
# print(sorted_year)
# 创建时间线对象
timeline=Timeline( {"theme":ThemeType.ESSOS})
for year in sorted_year:
    data_dict[year].sort(key=lambda element:element[1],reverse=True)
    year_data=data_dict[year][0:8]    #取出前八
    x_data=[]
    y_data=[]
    for country_gdp in year_data:
        x_data.append(country_gdp[0]) #x轴添加国家
        y_data.append(country_gdp[1]/100000000) #y轴添加gdp数据
    #构建柱状图
    bar=Bar()
    x_data.reverse()
    y_data.reverse()
    bar.add_xaxis(x_data)
    bar.add_yaxis("GDP(亿)",y_data,label_opts=LabelOpts(position="right"))
    bar.reversal_axis()
    bar.set_global_opts(
        title_opts=TitleOpts(title=f"{year}年全球GDP前8国家")
    )

    timeline.add(bar,str(year))

timeline.add_schema(
    play_interval=200,
    is_timeline_show=True,
    is_auto_play=True,
    is_loop_play=True
)
timeline.render("1960-2019全球GDP前8国家.html")
```

## 文件

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240827144313123.png" alt="image-20240827144313123" style="zoom:70%;" />

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240827144349437.png" alt="image-20240827144349437" style="zoom:75%;" />

```py
def my_write():
    file=open('note.txt','w',encoding='utf-8')  #打开文件
    file.write('sdfsdgsetgwe')   # 写入文件
    file.close()   #关闭文件

my_write()
```

```py
def my_write(file,lst):
    f=open(file,'a',encoding='utf-8')
    f.writelines(lst)
    f.close()

lst=['姓名\t','年龄\t','成绩\n','张三\t','18\t','90\t']
my_write('1.txt',lst)
```



### with 语句

处理文件时，无论是否产生异常，都能保证with语句执行完毕后关闭已经打开的文件，避免遗漏掉close方法

![image-20240827150304530](C:\Users\李晓慧\Desktop\笔记\image-20240827150304530.png)

```py
with open('1.txt','a',encoding='utf-8') as f:
    f.write('你好世界')

with open('1.txt','r',encoding='utf-8') as f:
    print(f.read())

# 文件复制
with open('1.txt','r',encoding='utf-8') as f1:
    with open('2.txt','w',encoding='utf-8') as f2:
        f2.write(f1.read())
```

 

### json 模块

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240827151810527.png" alt="image-20240827151810527" style="zoom:80%;" />

```py
import json
lst=[
    {'name':'jack','age':18,'score':90},
    {'name':'lisi','age':24,'score':79},
    {'name':'zs','age':20,'score':88}
]
# json格式
lst_json=json.dumps(lst,ensure_ascii=False,indent=4)  # ensure_ascii正常显示中文，index增加数据的缩进
print(lst_json)

# 解码json格式
lst2=json.loads(lst_json)
print(lst2)  # [{'name': 'jack', 'age': 18, 'score': 90}, {'name': 'lisi', 'age': 24, 'score': 79}, {'name': 'zs', 'age': 20, 'score': 88}]

# 编码到文件中
with open('student.txt','w') as file:
    json.dump(lst,file,ensure_ascii=False,indent=4)  # 转存到文件中
```



## 进阶

### 闭包

- 定义双层嵌套函数内层函数可以访问外层函数的变量


- **将内存函数作为外层函数的返回，此内层函数就是闭包函数**
- 闭包能够记住外部函数的集合，这些变量的引用被内部函数所保持

特点：

1. 环境捕捉：**闭包可以访问操作外部函数的变量，即使外部函数已经返回**
2. 状态保持：闭包可以保持状态，因为它们可以访问外部函数的非全局变量
3. 数据封装：闭包可以封装数据，隐藏实现细节，只暴露必要的接口

缺点:
所以会导致这一部分内存空间不被释放由开内部函数持续引用外部函数的值，一 直占用内存

```py
def outer(logo):

    def inner(msg):
        print(f'{logo}---{msg}---{logo}')

    return inner

s=outer('nihao')
s('世界')  # nihao---世界---nihao


def create_closure():
    # 外部函数的变量
    external_var='i am external'

    def closure():
        return external_var

    return closure

# 创建闭包
my_closure=create_closure()
# 调用闭包
print(my_closure())   # i am external
```

#### nonlocal

```py
def outer(num1):

    def inner(num2):
        nonlocal num1  # 需要使用nonlocal关键字修饰外部函数的变量才可在内部函数中修改它
        # num1=5
        num1 += num2
        print(num1)

    return inner

s=outer(10)
s(10)  # 20
```

atm小案例

【注意】：

1. **`return atm`**:返回的是这个函数本身，`atm` 作为一个闭包被返回，它仍然可以访问 `initial_amount` 变量，用来追踪账户的余额
2. **`return atm()`**:返回的是这个函数的返回值，不能从 `account_create` 获得一个可以重复使用的 `atm` 函数，而只能调用一次，并且这个调用立即执行了 `atm` 函数

```py
def account_create(initial_amount):

    def atm(num,deposit=True):
        nonlocal initial_amount
        if deposit:
            initial_amount += num
            print(f'存款：+{num},账户余额：{initial_amount}')
        else:
            initial_amount -=num
            print(f'取款：-{num},账户余额：{initial_amount}')
    return atm

initial_amount=0
atm=account_create(initial_amount)
atm(100)       # 存款：+100,账户余额：100
atm(10,False)  # 取款：-10,账户余额：90
'''
initial_amount 作为 account_create 函数的局部变量，在 account_create 返回后并没有被销毁，因为 atm 闭包持有对其的引用。
所以，initial_amount 的值在两次调用之间是持续存在的，并且保持了其状态。
闭包 atm 记住了 initial_amount 的值，即使 account_create 函数已经执行完毕。每次调用 atm 时，都是基于 initial_amount 当前的值来进行操作的。
'''
```



### 装饰器

语法糖：

```py
# outer()函数是一个装饰器
def outer(func):
    # 闭包函数inner()
    def inner():  # 这个函数应该接收调用func时传入的参数
        print('睡觉....')
        func()  # 调用原始的sleep函数
        print('起床了')
    return inner

@outer  # 这相当于 sleep = outer(sleep)，将装饰器outer应用于sleep函数
def sleep():
    print('睡眠中')

sleep()  # 调用被装饰后的sleep函数，实际上是在调用被 outer 装饰的 inner 函数。
```

![image-20240829143116369](C:\Users\李晓慧\Desktop\笔记\image-20240829143116369.png)

### 设计模式

设计模式是一种编程套路，可以极大的方便程序的开发，最常见、最经典的设计模式就是面向对象，还有其他的：单例、工厂模式等

#### 单例模式

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240522200020845.png" alt="image-20240522200020845" style="zoom:80%;" />

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240522200121916.png" alt="image-20240522200121916" style="zoom:80%;" />



#### 工厂模式

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240522200726724.png" alt="image-20240522200726724" style="zoom:80%;" />

   

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240522200842505.png" alt="image-20240522200842505" style="zoom:80%;" />

## socket 套接字

套接字（Socket）是用于两点之间的通信的编程接口，它是一个抽象层，隐藏了网络通信的复杂性，使得网络通信对程序员来说更加容易处理。

特点：

- socket具有网络地址和端口号，这两者共同唯一确定了网络中的一个通信端点
- 支持双向通信，即可以发送数据也可以接收数据
- 多类型，以适应不同的网络协议和通信需求



![image-20240829144342200](C:\Users\李晓慧\Desktop\笔记\image-20240829144342200.png)

![image-20240829144454666](C:\Users\李晓慧\Desktop\笔记\image-20240829144454666.png)



#### TCP服务端流程:

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240829144653141.png" alt="image-20240829144653141" style="zoom: 67%;" />

 

```py
import socket

# 1.创建socket对象
server_socket=socket.socket()

# 2.绑定IP地址和端口
ip='127.0.0.1'
port=8888
server_socket.bind((ip,port))

# 3.使用listen()监听
server_socket.listen(5)
print('服务已启动')

# 4.等待客户端连接
client_socket,client_addr=server_socket.accept()  # 解包赋值

# 5.接收客户端传来的数据
data=client_socket.recv(1024)
print('客户端传来的数据：',data.decode('utf-8'))

# 6.关闭socket
server_socket.close()
```



#### TCP客户端流程：

<img src="C:\Users\李晓慧\Desktop\笔记\image-20240829145305244.png" alt="image-20240829145305244" style="zoom:67%;" />

```py
# 客户端
import socket

# 1.创建socket对象
client_socket=socket.socket()

# 2.IP地址和端口，向服务端发送连接请求
ip='127.0.0.1'
port=8888
client_socket.connect((ip,port))
print('与服务器连接成功')

# 3.发送数据
client_socket.send('hello ninao do you eating?'.encode('utf-8'))

# 4.关闭
client_socket.close()
print('发送完毕')
```
